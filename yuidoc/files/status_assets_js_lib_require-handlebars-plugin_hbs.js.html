<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>status/assets/js/lib/require-handlebars-plugin/hbs.js - The Blintus Status API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="The Blintus Status API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/HomeController.html">HomeController</a></li>
            
                <li><a href="../classes/HomeView.html">HomeView</a></li>
            
                <li><a href="../classes/Store.html">Store</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: status/assets/js/lib/require-handlebars-plugin/hbs.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @license Handlebars hbs 0.8.1 - Alex Sexton, but Handlebars has its own licensing junk
 *
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/require-cs for details on the plugin this was based off of
 */

/* Yes, deliciously evil. */
/*jslint evil: true, strict: false, plusplus: false, regexp: false */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
define: false, process: false, window: false */
define([
//&gt;&gt;excludeStart(&#x27;excludeHbs&#x27;, pragmas.excludeHbs)
  &#x27;hbs/handlebars&#x27;, &#x27;hbs/underscore&#x27;, &#x27;hbs/i18nprecompile&#x27;, &#x27;hbs/json2&#x27;
//&gt;&gt;excludeEnd(&#x27;excludeHbs&#x27;)
], function (
//&gt;&gt;excludeStart(&#x27;excludeHbs&#x27;, pragmas.excludeHbs)
  Handlebars, _, precompile, JSON
//&gt;&gt;excludeEnd(&#x27;excludeHbs&#x27;)
) {
  //&gt;&gt;excludeStart(&#x27;excludeHbs&#x27;, pragmas.excludeHbs)
  var fs;
  var getXhr;
  var progIds = [&#x27;Msxml2.XMLHTTP&#x27;, &#x27;Microsoft.XMLHTTP&#x27;, &#x27;Msxml2.XMLHTTP.4.0&#x27;];
  var fetchText = function () {
      throw new Error(&#x27;Environment unsupported.&#x27;);
  };
  var buildMap = [];
  var filecode = &#x27;w+&#x27;;
  var templateExtension = &#x27;hbs&#x27;;
  var customNameExtension = &#x27;@hbs&#x27;;
  var devStyleDirectory = &#x27;/styles/&#x27;;
  var buildStyleDirectory = &#x27;/demo-build/styles/&#x27;;
  var helperDirectory = &#x27;templates/helpers/&#x27;;
  var i18nDirectory = &#x27;templates/i18n/&#x27;;
  var buildCSSFileName = &#x27;screen.build.css&#x27;;
  var onHbsReadMethod = &quot;onHbsRead&quot;;

  Handlebars.registerHelper(&#x27;$&#x27;, function() {
    //placeholder for translation helper
  });

  if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window.navigator &amp;&amp; window.document &amp;&amp; !window.navigator.userAgent.match(/Node.js/)) {
    // Browser action
    getXhr = function () {
      // Would love to dump the ActiveX crap in here. Need IE 6 to die first.
      var xhr;
      var i;
      var progId;
      if (typeof XMLHttpRequest !== &#x27;undefined&#x27;) {
        return ((arguments[0] === true)) ? new XDomainRequest() : new XMLHttpRequest();
      }
      else {
        for (i = 0; i &lt; 3; i++) {
          progId = progIds[i];
          try {
            xhr = new ActiveXObject(progId);
          }
          catch (e) {}

          if (xhr) {
            // Faster next time
            progIds = [progId];
            break;
          }
        }
      }

      if (!xhr) {
          throw new Error(&#x27;getXhr(): XMLHttpRequest not available&#x27;);
      }

      return xhr;
    };

    // Returns the version of Windows Internet Explorer or a -1
    // (indicating the use of another browser).
    // Note: this is only for development mode. Does not run in production.
    getIEVersion = function(){
      // Return value assumes failure.
      var rv = -1;
      if (navigator.appName == &#x27;Microsoft Internet Explorer&#x27;) {
        var ua = navigator.userAgent;
        var re = new RegExp(&#x27;MSIE ([0-9]{1,}[\.0-9]{0,})&#x27;);
        if (re.exec(ua) != null) {
          rv = parseFloat( RegExp.$1 );
        }
      }
      return rv;
    };

    fetchText = function (url, callback) {
      var xdm = false;
      // If url is a fully qualified URL, it might be a cross domain request. Check for that.
	  // IF url is a relative url, it cannot be cross domain.
      if (url.indexOf(&#x27;http&#x27;) != 0 ){
          xdm = false;
      }else{
          var uidx = (url.substr(0,5) === &#x27;https&#x27;) ? 8 : 7;
          var hidx = (window.location.href.substr(0,5) === &#x27;https&#x27;) ? 8 : 7;
          var dom = url.substr(uidx).split(&#x27;/&#x27;).shift();
          var msie = getIEVersion();
              xdm = ( dom != window.location.href.substr(hidx).split(&#x27;/&#x27;).shift() ) &amp;&amp; (msie &gt;= 7);
      }

      if ( xdm ) {
         var xdr = getXhr(true);
        xdr.open(&#x27;GET&#x27;, url);
        xdr.onload = function() {
          callback(xdr.responseText, url);
        };
        xdr.onprogress = function(){};
        xdr.ontimeout = function(){};
        xdr.onerror = function(){};
        setTimeout(function(){
          xdr.send();
        }, 0);
      }
      else {
        var xhr = getXhr();
        xhr.open(&#x27;GET&#x27;, url, true);
        xhr.onreadystatechange = function (evt) {
          //Do not explicitly handle errors, those should be
          //visible via console output in the browser.
          if (xhr.readyState === 4) {
            callback(xhr.responseText, url);
          }
        };
        xhr.send(null);
      }
    };

  }
  else if (
    typeof process !== &#x27;undefined&#x27; &amp;&amp;
    process.versions &amp;&amp;
    !!process.versions.node
  ) {
    //Using special require.nodeRequire, something added by r.js.
    fs = require.nodeRequire(&#x27;fs&#x27;);
    fetchText = function ( path, callback ) {
      var body = fs.readFileSync(path, &#x27;utf8&#x27;) || &#x27;&#x27;;
      // we need to remove BOM stuff from the file content
      body = body.replace(/^\uFEFF/, &#x27;&#x27;);
      callback(body, path);
    };
  }
  else if (typeof java !== &#x27;undefined&#x27; &amp;&amp; typeof java.io !== &#x27;undefined&#x27;) {
    fetchText = function(path, callback) {
      var fis = new java.io.FileInputStream(path);
      var streamReader = new java.io.InputStreamReader(fis, &quot;UTF-8&quot;);
      var reader = new java.io.BufferedReader(streamReader);
      var line;
      var text = &#x27;&#x27;;
      while ((line = reader.readLine()) !== null) {
        text += new String(line) + &#x27;\n&#x27;;
      }
      reader.close();
      callback(text, path);
    };
  }

  var cache = {};
  var fetchOrGetCached = function ( path, callback ){
    if ( cache[path] ){
      callback(cache[path]);
    }
    else {
      fetchText(path, function(data, path){
        cache[path] = data;
        callback.call(this, data);
      });
    }
  };
  var styleList = [];
  var styleMap = {};
  //&gt;&gt;excludeEnd(&#x27;excludeHbs&#x27;)

  return {

    get: function () {
      return Handlebars;
    },

    write: function (pluginName, name, write) {
      if ( (name + customNameExtension ) in buildMap) {
        var text = buildMap[name + customNameExtension];
        write.asModule(pluginName + &#x27;!&#x27; + name, text);
      }
    },

    version: &#x27;0.8.1&#x27;,

    load: function (name, parentRequire, load, config) {
      //&gt;&gt;excludeStart(&#x27;excludeHbs&#x27;, pragmas.excludeHbs)

      var compiledName = name + customNameExtension;
      config.hbs = config.hbs || {};
      var disableI18n = !(config.hbs.i18n == true); // by default we disable i18n unless config.hbs.i18n is true
      var disableHelpers = (config.hbs.helpers == false); // be default we enable helpers unless config.hbs.helpers is false
      var partialsUrl = &#x27;&#x27;;
      if(config.hbs.partialsUrl) {
        partialsUrl = config.hbs.partialsUrl;
        if(!partialsUrl.match(/\/$/)) partialsUrl += &#x27;/&#x27;;
      }

      // Let redefine default fetchText
      if(config.hbs.fetchText) {
          fetchText = config.hbs.fetchText;
      }

      var partialDeps = [];

      function recursiveNodeSearch( statements, res ) {
        _(statements).forEach(function ( statement ) {
          if ( statement &amp;&amp; statement.type &amp;&amp; statement.type === &#x27;partial&#x27; ) {
            res.push(statement.partialName.name);
          }
          if ( statement &amp;&amp; statement.program &amp;&amp; statement.program.statements ) {
            recursiveNodeSearch( statement.program.statements, res );
          }
          if ( statement &amp;&amp; statement.program &amp;&amp; statement.program.inverse &amp;&amp; statement.program.inverse.statements ) {
            recursiveNodeSearch( statement.program.inverse.statements, res );
          }
        });
        return res;
      }

      // TODO :: use the parser to do this!
      function findPartialDeps( nodes ) {
        var res = [];
        if ( nodes &amp;&amp; nodes.statements ) {
          res = recursiveNodeSearch( nodes.statements, [] );
        }
        return _.unique(res);
      }

      // See if the first item is a comment that&#x27;s json
      function getMetaData( nodes ) {
        var statement, res, test;
        if ( nodes &amp;&amp; nodes.statements ) {
          statement = nodes.statements[0];
          if ( statement &amp;&amp; statement.type === &#x27;comment&#x27; ) {
            try {
              res = ( statement.comment ).replace(new RegExp(&#x27;^[\\s]+|[\\s]+$&#x27;, &#x27;g&#x27;), &#x27;&#x27;);
              test = JSON.parse(res);
              return res;
            }
            catch (e) {
              return JSON.stringify({
                description: res
              });
            }
          }
        }
        return &#x27;{}&#x27;;
      }

      function composeParts ( parts ) {
        if ( !parts ) {
          return [];
        }
        var res = [parts[0]];
        var cur = parts[0];
        var i;

        for (i = 1; i &lt; parts.length; ++i) {
          if ( parts.hasOwnProperty(i) ) {
            cur += &#x27;.&#x27; + parts[i];
            res.push( cur );
          }
        }
        return res;
      }

      function recursiveVarSearch( statements, res, prefix, helpersres ) {
        prefix = prefix ? prefix + &#x27;.&#x27; : &#x27;&#x27;;

        var  newprefix = &#x27;&#x27;;
        var flag = false;

        // loop through each statement
        _(statements).forEach(function(statement) {
          var parts;
          var part;
          var sideways;

          // if it&#x27;s a mustache block
          if ( statement &amp;&amp; statement.type &amp;&amp; statement.type === &#x27;mustache&#x27; ) {

            // If it has params, the first part is a helper or something
            if ( !statement.params || ! statement.params.length ) {
              parts = composeParts( statement.id.parts );
              for( part in parts ) {
                if ( parts[ part ] ) {
                  newprefix = parts[ part ] || newprefix;
                  res.push( prefix + parts[ part ] );
                }
              }
              res.push(prefix + statement.id.string);
            }

            var paramsWithoutParts = [&#x27;this&#x27;, &#x27;.&#x27;, &#x27;..&#x27;, &#x27;./..&#x27;, &#x27;../..&#x27;, &#x27;../../..&#x27;];

            // grab the params
            if ( statement.params &amp;&amp; typeof Handlebars.helpers[statement.id.string] === &#x27;undefined&#x27;) {
              _(statement.params).forEach(function(param) {
                if ( _(paramsWithoutParts).contains(param.original)
                  || param instanceof Handlebars.AST.StringNode
                  || param instanceof Handlebars.AST.IntegerNode
                  || param instanceof Handlebars.AST.BooleanNode
                  || param instanceof Handlebars.AST.DataNode
                  || param instanceof Handlebars.AST.SexprNode
                ) {
                  helpersres.push(statement.id.string);

                  // Look into the params to find subexpressions
                  if (typeof statement.params !== &#x27;undefined&#x27;) {
                      _(statement.params).forEach(function(param) {
                        if (param.type === &#x27;sexpr&#x27; &amp;&amp; param.isHelper === true) {
                          // Found subexpression in params
                          helpersres.push(param.id.string);
                        }
                      });
                  }

                  // Look in the hash to find sub expressions
                  if ((statement.hash != null) &amp;&amp; (typeof statement.hash !== &#x27;undefined&#x27;) &amp;&amp; (typeof statement.hash.pairs !== &#x27;undefined&#x27;)) {
                    _(statement.hash.pairs).forEach(function(pair) {
                      var pairName = pair[0],
                          pairValue = pair[1];
                      if (pairValue.type === &#x27;sexpr&#x27; &amp;&amp; pairValue.isHelper === true) {
                        // Found subexpression in hash params
                        helpersres.push(pairValue.id.string);
                      }
                    });
                  }
                }

                parts = composeParts( param.parts );

                for(var part in parts ) {
                  if ( parts[ part ] ) {
                    newprefix = parts[part] || newprefix;
                    helpersres.push(statement.id.string);
                    res.push( prefix + parts[ part ] );
                  }
                }
              });
              if ((statement.hash != null) &amp;&amp; (typeof statement.hash !== &#x27;undefined&#x27;) &amp;&amp; (typeof statement.hash.pairs !== &#x27;undefined&#x27;)) {
                //Even if it has no regular params, it may be a helper with hash params
                _(statement.hash.pairs).forEach(function(pair) {
                  var pairValue = pair[1];
                  if (pairValue instanceof Handlebars.AST.StringNode
                    || pairValue instanceof Handlebars.AST.IntegerNode
                    || pairValue instanceof Handlebars.AST.BooleanNode
                    || pairValue instanceof Handlebars.AST.IdNode
                    //TODO: Add support for subexpressions here?
                  ) {
                    helpersres.push(statement.id.string);
                  }
                });
              }
            }
          }

          // If it&#x27;s a meta block
          if ( statement &amp;&amp; statement.mustache  ) {
            recursiveVarSearch( [statement.mustache], res, prefix + newprefix, helpersres );
          }

          // if it&#x27;s a whole new program
          if ( statement &amp;&amp; statement.program &amp;&amp; statement.program.statements ) {
            sideways = recursiveVarSearch([statement.mustache],[], &#x27;&#x27;, helpersres)[0] || &#x27;&#x27;;
            if ( statement.program.inverse &amp;&amp; statement.program.inverse.statements ) {
              recursiveVarSearch( statement.program.inverse.statements, res, prefix + newprefix + (sideways ? (prefix+newprefix) ? &#x27;.&#x27;+sideways : sideways : &#x27;&#x27;), helpersres);
            }
            recursiveVarSearch( statement.program.statements, res, prefix + newprefix + (sideways ? (prefix+newprefix) ? &#x27;.&#x27;+sideways : sideways : &#x27;&#x27;), helpersres);
          }
        });
        return res;
      }

      // This finds the Helper dependencies since it&#x27;s soooo similar
      function getExternalDeps( nodes ) {
        var res   = [];
        var helpersres = [];

        if ( nodes &amp;&amp; nodes.statements ) {
          res = recursiveVarSearch( nodes.statements, [], undefined, helpersres );
        }

        var defaultHelpers = [
          &#x27;helperMissing&#x27;,
          &#x27;blockHelperMissing&#x27;,
          &#x27;each&#x27;,
          &#x27;if&#x27;,
          &#x27;unless&#x27;,
          &#x27;with&#x27;
        ];

        return {
          vars: _(res).chain().unique().map(function(e) {
            if ( e === &#x27;&#x27; ) {
              return &#x27;.&#x27;;
            }
            if ( e.length &amp;&amp; e[e.length-1] === &#x27;.&#x27; ) {
              return e.substr(0,e.length-1) + &#x27;[]&#x27;;
            }
            return e;
          }).value(),

          helpers: _(helpersres).chain().unique().map(function(e){
            if ( _(defaultHelpers).contains(e) ) {
              return undefined;
            }
            return e;
          }).compact().value()
        };
      }

      function cleanPath(path) {
        var tokens = path.split(&#x27;/&#x27;);
        for(var i=0;i&lt;tokens.length; i++) {
          if(tokens[i] == &#x27;..&#x27;) {
            delete tokens[i-1];
            delete tokens[i];
          }
        }
        return tokens.join(&#x27;/&#x27;).replace(/\/\/+/g,&#x27;/&#x27;);
      };

      function fetchAndRegister(langMap) {
          fetchText(path, function(text, path) {

          var readCallback = (config.isBuild &amp;&amp; config[onHbsReadMethod]) ? config[onHbsReadMethod]:  function(name,path,text){return text} ;
          // for some reason it doesn&#x27;t include hbs _first_ when i don&#x27;t add it here...
          var nodes = Handlebars.parse( readCallback(name, path, text));
          var partials = findPartialDeps( nodes );
          var meta = getMetaData( nodes );
          var extDeps = getExternalDeps( nodes );
          var vars = extDeps.vars;
          var helps = (extDeps.helpers || []);
          var debugOutputStart = &#x27;&#x27;;
          var debugOutputEnd   = &#x27;&#x27;;
          var debugProperties = &#x27;&#x27;;
          var deps = [];
          var depStr, helpDepStr, metaObj, head, linkElem;
          var baseDir = name.substr(0,name.lastIndexOf(&#x27;/&#x27;)+1);

          require.config.hbs = require.config.hbs || {};
          require.config.hbs._partials = require.config.hbs._partials || {};

          if(meta !== &#x27;{}&#x27;) {
            try {
              metaObj = JSON.parse(meta);
            } catch(e) {
              console.log(&#x27;couldn\&#x27;t parse meta for %s&#x27;, path);
            }
          }

          for ( var i in partials ) {
            if ( partials.hasOwnProperty(i) &amp;&amp; typeof partials[i] === &#x27;string&#x27;) {  // make sure string, because we&#x27;re iterating over all props
              var partialReference = partials[i];

              var path;
              if(partialReference.match(/^(\.|\/)+/)) {
                // relative path
                path = cleanPath(baseDir + partialReference)
              }
              else {
                // absolute path relative to config.hbs.partialsUrl if defined
                path = cleanPath(partialsUrl + partialReference);
              }

              require.config.hbs._partials[path] = require.config.hbs._partials[path] || [];

              // we can reference a same template with different paths (with absolute or relative)
              require.config.hbs._partials[path].references = require.config.hbs._partials[path].references || [];
              require.config.hbs._partials[path].references.push(partialReference);

              require.config.hbs._loadedDeps = require.config.hbs._loadedDeps || {};

              deps[i] = &quot;hbs!&quot;+path;
            }
          }

          depStr = deps.join(&quot;&#x27;, &#x27;&quot;);

          helps = helps.concat((metaObj &amp;&amp; metaObj.helpers) ? metaObj.helpers : []);
          helpDepStr = disableHelpers ?
            &#x27;&#x27; : (function (){
              var i;
              var paths = [];
              var pathGetter = config.hbs &amp;&amp; config.hbs.helperPathCallback
                ? config.hbs.helperPathCallback
                : function (name){
                  return (config.hbs &amp;&amp; config.hbs.helperDirectory ? config.hbs.helperDirectory : helperDirectory) + name;
                };

              for ( i = 0; i &lt; helps.length; i++ ) {
                paths[i] = &quot;&#x27;&quot; + pathGetter(helps[i], path) + &quot;&#x27;&quot;
              }
              return paths;
            })().join(&#x27;,&#x27;);

          if ( helpDepStr ) {
            helpDepStr = &#x27;,&#x27; + helpDepStr;
          }

          if (metaObj) {
            try {
              if (metaObj.styles) {
                styleList = _.union(styleList, metaObj.styles);

                // In dev mode in the browser
                if ( require.isBrowser &amp;&amp; ! config.isBuild ) {
                  head = document.head || document.getElementsByTagName(&#x27;head&#x27;)[0];
                  _(metaObj.styles).forEach(function (style) {
                    if ( !styleMap[style] ) {
                      linkElem = document.createElement(&#x27;link&#x27;);
                      linkElem.href = config.baseUrl + devStyleDirectory + style + &#x27;.css&#x27;;
                      linkElem.media = &#x27;all&#x27;;
                      linkElem.rel = &#x27;stylesheet&#x27;;
                      linkElem.type = &#x27;text/css&#x27;;
                      head.appendChild(linkElem);
                      styleMap[style] = linkElem;
                    }
                  });
                }
                else if ( config.isBuild ) {
                  (function(){
                    var fs  = require.nodeRequire(&#x27;fs&#x27;);
                    var str = _(metaObj.styles).map(function (style) {
                      if (!styleMap[style]) {
                        styleMap[style] = true;
                        return &#x27;@import url(&#x27;+style+&#x27;.css);\n&#x27;;
                      }
                      return &#x27;&#x27;;
                    }).join(&#x27;\n&#x27;);

                    // I write out my import statements to a file in order to help me build stuff.
                    // Then I use a tool to inline my import statements afterwards. (you can run r.js on it too)
                    fs.open(__dirname + buildStyleDirectory + buildCSSFileName, filecode, &#x27;0666&#x27;, function( e, id ) {
                      fs.writeSync(id, str, null, encoding=&#x27;utf8&#x27;);
                      fs.close(id);
                    });
                    filecode = &#x27;a&#x27;;
                  })();
                }
              }
            }
            catch(e){
              console.log(&#x27;error injecting styles&#x27;);
            }
          }

          if ( ! config.isBuild &amp;&amp; ! config.serverRender ) {
            debugOutputStart = &#x27;&lt;!-- START - &#x27; + name + &#x27; --&gt;&#x27;;
            debugOutputEnd = &#x27;&lt;!-- END - &#x27; + name + &#x27; --&gt;&#x27;;
            debugProperties = &#x27;t.meta = &#x27; + meta + &#x27;;\n&#x27; +
                              &#x27;t.helpers = &#x27; + JSON.stringify(helps) + &#x27;;\n&#x27; +
                              &#x27;t.deps = &#x27; + JSON.stringify(deps) + &#x27;;\n&#x27; +
                              &#x27;t.vars = &#x27; + JSON.stringify(vars) + &#x27;;\n&#x27;;
          }

          var mapping = disableI18n? false : _.extend( langMap, config.localeMapping );
          var configHbs = config.hbs || {};
          var options = _.extend(configHbs.compileOptions || {}, { originalKeyFallback: configHbs.originalKeyFallback });
          var prec = precompile( text, mapping, options);
          var tmplName = config.isBuild ? &#x27;&#x27; : &quot;&#x27;&quot; + name + &quot;&#x27;,&quot;;

          if(depStr) depStr = &quot;, &#x27;&quot;+depStr+&quot;&#x27;&quot;;

          var partialReferences = [];
          if(require.config.hbs._partials[name])
            partialReferences = require.config.hbs._partials[name].references;

          text = &#x27;/* START_TEMPLATE */\n&#x27; +
                 &#x27;define(&#x27;+tmplName+&quot;[&#x27;hbs&#x27;,&#x27;hbs/handlebars&#x27;&quot;+depStr+helpDepStr+&#x27;], function( hbs, Handlebars ){ \n&#x27; +
                   &#x27;var t = Handlebars.template(&#x27; + prec + &#x27;);\n&#x27; +
                   &quot;Handlebars.registerPartial(&#x27;&quot; + name + &quot;&#x27;, t);\n&quot;;

          for(var i=0; i&lt;partialReferences.length;i++)
            text += &quot;Handlebars.registerPartial(&#x27;&quot; + partialReferences[i] + &quot;&#x27;, t);\n&quot;;

          text += debugProperties +
                   &#x27;return t;\n&#x27; +
                 &#x27;});\n&#x27; +
                 &#x27;/* END_TEMPLATE */\n&#x27;;

          //Hold on to the transformed text if a build.
          if (config.isBuild) {
            buildMap[compiledName] = text;
          }

          //IE with conditional comments on cannot handle the
          //sourceURL trick, so skip it if enabled.
          /*@if (@_jscript) @else @*/
          if (!config.isBuild) {
            text += &#x27;\r\n//# sourceURL=&#x27; + path;
          }
          /*@end@*/

          if ( !config.isBuild ) {
            require( deps, function (){
              load.fromText(text);

              //Give result to load. Need to wait until the module
              //is fully parse, which will happen after this
              //execution.
              parentRequire([name], function (value) {
                load(value);
              });
            });
          }
          else {
            load.fromText(name, text);

            //Give result to load. Need to wait until the module
            //is fully parse, which will happen after this
            //execution.
            parentRequire([name], function (value) {
              load(value);
            });
          }

          if ( config.removeCombined &amp;&amp; path ) {
            fs.unlinkSync(path);
          }

        });
      }

      var path;
      var omitExtension = config.hbs &amp;&amp; config.hbs.templateExtension === false;

      if (omitExtension) {
        path = parentRequire.toUrl(name);
      }
      else {
        path = parentRequire.toUrl(name +&#x27;.&#x27;+ (config.hbs &amp;&amp; config.hbs.templateExtension ? config.hbs.templateExtension : templateExtension));
      }

      if (disableI18n){
        fetchAndRegister(false);
      }
      else {
        // Workaround until jam is able to pass config info or we move i18n to a separate module.
        // This logs a warning and disables i18n if there&#x27;s an error loading the language file
        var langMapPath = (config.hbs &amp;&amp; config.hbs.i18nDirectory ? config.hbs.i18nDirectory : i18nDirectory) + (config.locale || &#x27;en_us&#x27;) + &#x27;.json&#x27;;
        try {
          fetchOrGetCached(parentRequire.toUrl(langMapPath), function (langMap) {
            fetchAndRegister(JSON.parse(langMap));
          });
        }
        catch(er) {
          // if there&#x27;s no configuration at all, log a warning and disable i18n for this and subsequent templates
          if(!config.hbs) {
            console.warn(&#x27;hbs: Error reading &#x27; + langMapPath + &#x27;, disabling i18n. Ignore this if you\&#x27;re using jam, otherwise check your i18n configuration.\n&#x27;);
            config.hbs = {i18n: false, helpers: true};
            fetchAndRegister(false);
          }
          else {
            throw er;
          }
        }
      }
      //&gt;&gt;excludeEnd(&#x27;excludeHbs&#x27;)
    }
  };
});
/* END_hbs_PLUGIN */

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
